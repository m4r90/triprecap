{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { State } from '../../State';\nimport { PointerType } from '../interfaces';\nimport PointerTracker from './PointerTracker';\nexport default class GestureHandlerOrchestrator {\n  constructor() {\n    _defineProperty(this, \"gestureHandlers\", []);\n    _defineProperty(this, \"awaitingHandlers\", []);\n    _defineProperty(this, \"handlingChangeSemaphore\", 0);\n    _defineProperty(this, \"activationIndex\", 0);\n  }\n  scheduleFinishedHandlersCleanup() {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n  cleanHandler(handler) {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n  removeHandlerFromOrchestrator(handler) {\n    this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n    this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n  }\n  cleanupFinishedHandlers() {\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n      if (!handler) {\n        continue;\n      }\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.gestureHandlers.splice(i, 1);\n        this.cleanHandler(handler);\n      }\n    }\n  }\n  hasOtherHandlerToWaitFor(handler) {\n    let hasToWait = false;\n    this.gestureHandlers.forEach(otherHandler => {\n      if (otherHandler && !this.isFinished(otherHandler.getState()) && this.shouldHandlerWaitForOther(handler, otherHandler)) {\n        hasToWait = true;\n        return;\n      }\n    });\n    return hasToWait;\n  }\n  tryActivate(handler) {\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n    } else if (handler.getState() !== State.CANCELLED && handler.getState() !== State.FAILED) {\n      if (this.shouldActivate(handler)) {\n        this.makeActive(handler);\n      } else {\n        switch (handler.getState()) {\n          case State.ACTIVE:\n            handler.fail();\n            break;\n          case State.BEGAN:\n            handler.cancel();\n        }\n      }\n    }\n  }\n  shouldActivate(handler) {\n    for (const otherHandler of this.gestureHandlers) {\n      if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  cleanupAwaitingHandlers(handler) {\n    for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n      if (!this.awaitingHandlers[i].isAwaiting() && this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)) {\n        this.cleanHandler(this.awaitingHandlers[i]);\n        this.awaitingHandlers.splice(i, 1);\n      }\n    }\n  }\n  onHandlerStateChange(handler, newState, oldState, sendIfDisabled) {\n    if (!handler.isEnabled() && !sendIfDisabled) {\n      return;\n    }\n    this.handlingChangeSemaphore += 1;\n    if (this.isFinished(newState)) {\n      this.awaitingHandlers.forEach(otherHandler => {\n        if (this.shouldHandlerWaitForOther(otherHandler, handler)) {\n          if (newState === State.END) {\n            otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.cancel();\n            if (otherHandler.getState() === State.END) {\n              otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n            }\n            otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.setAwaiting(false);\n          } else {\n            this.tryActivate(otherHandler);\n          }\n        }\n      });\n    }\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(newState, oldState);\n      } else if (oldState === State.ACTIVE && (newState === State.CANCELLED || newState === State.FAILED)) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (oldState !== State.UNDETERMINED || newState !== State.CANCELLED) {\n      handler.sendEvent(newState, oldState);\n    }\n    this.handlingChangeSemaphore -= 1;\n    this.scheduleFinishedHandlersCleanup();\n    if (this.awaitingHandlers.indexOf(handler) < 0) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n  makeActive(handler) {\n    const currentState = handler.getState();\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      if (this.shouldHandlerBeCancelledBy(this.gestureHandlers[i], handler)) {\n        this.gestureHandlers[i].cancel();\n      }\n    }\n    this.awaitingHandlers.forEach(otherHandler => {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.cancel();\n        otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.setAwaiting(true);\n      }\n    });\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n    if (handler.isAwaiting()) {\n      handler.setAwaiting(false);\n      for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (this.awaitingHandlers[i] === handler) {\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n  }\n  addAwaitingHandler(handler) {\n    let alreadyExists = false;\n    this.awaitingHandlers.forEach(otherHandler => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n    if (alreadyExists) {\n      return;\n    }\n    this.awaitingHandlers.push(handler);\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n  recordHandlerIfNotPresent(handler) {\n    let alreadyExists = false;\n    this.gestureHandlers.forEach(otherHandler => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n    if (alreadyExists) {\n      return;\n    }\n    this.gestureHandlers.push(handler);\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n  shouldHandlerWaitForOther(handler, otherHandler) {\n    return handler !== otherHandler && (handler.shouldWaitForHandlerFailure(otherHandler) || otherHandler.shouldRequireToWaitForFailure(handler));\n  }\n  canRunSimultaneously(gh1, gh2) {\n    return gh1 === gh2 || gh1.shouldRecognizeSimultaneously(gh2) || gh2.shouldRecognizeSimultaneously(gh1);\n  }\n  shouldHandlerBeCancelledBy(handler, otherHandler) {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n    if (handler !== otherHandler && (handler.isAwaiting() || handler.getState() === State.ACTIVE)) {\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n    const handlerPointers = handler.getTrackedPointersID();\n    const otherPointers = otherHandler.getTrackedPointersID();\n    if (!PointerTracker.shareCommonPointers(handlerPointers, otherPointers) && handler.getDelegate().getView() !== otherHandler.getDelegate().getView()) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n    return true;\n  }\n  checkOverlap(handler, otherHandler) {\n    const handlerPointers = handler.getTrackedPointersID();\n    const otherPointers = otherHandler.getTrackedPointersID();\n    let overlap = false;\n    handlerPointers.forEach(pointer => {\n      const handlerX = handler.getTracker().getLastX(pointer);\n      const handlerY = handler.getTracker().getLastY(pointer);\n      if (handler.getDelegate().isPointerInBounds({\n        x: handlerX,\n        y: handlerY\n      }) && otherHandler.getDelegate().isPointerInBounds({\n        x: handlerX,\n        y: handlerY\n      })) {\n        overlap = true;\n      }\n    });\n    otherPointers.forEach(pointer => {\n      const otherX = otherHandler.getTracker().getLastX(pointer);\n      const otherY = otherHandler.getTracker().getLastY(pointer);\n      if (handler.getDelegate().isPointerInBounds({\n        x: otherX,\n        y: otherY\n      }) && otherHandler.getDelegate().isPointerInBounds({\n        x: otherX,\n        y: otherY\n      })) {\n        overlap = true;\n      }\n    });\n    return overlap;\n  }\n  isFinished(state) {\n    return state === State.END || state === State.FAILED || state === State.CANCELLED;\n  }\n  cancelMouseAndPenGestures(currentHandler) {\n    this.gestureHandlers.forEach(handler => {\n      if (handler.getPointerType() !== PointerType.MOUSE && handler.getPointerType() !== PointerType.PEN) {\n        return;\n      }\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n  static getInstance() {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n_defineProperty(GestureHandlerOrchestrator, \"instance\", void 0);","map":{"version":3,"names":["State","PointerType","PointerTracker","GestureHandlerOrchestrator","constructor","_defineProperty","scheduleFinishedHandlersCleanup","handlingChangeSemaphore","cleanupFinishedHandlers","cleanHandler","handler","reset","setActive","setAwaiting","setActivationIndex","Number","MAX_VALUE","removeHandlerFromOrchestrator","gestureHandlers","splice","indexOf","awaitingHandlers","i","length","isFinished","getState","isAwaiting","hasOtherHandlerToWaitFor","hasToWait","forEach","otherHandler","shouldHandlerWaitForOther","tryActivate","addAwaitingHandler","CANCELLED","FAILED","shouldActivate","makeActive","ACTIVE","fail","BEGAN","cancel","shouldHandlerBeCancelledBy","cleanupAwaitingHandlers","onHandlerStateChange","newState","oldState","sendIfDisabled","isEnabled","END","sendEvent","isActive","UNDETERMINED","currentState","setShouldResetProgress","activationIndex","alreadyExists","push","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","shouldBeCancelledByOther","handlerPointers","getTrackedPointersID","otherPointers","shareCommonPointers","getDelegate","getView","checkOverlap","overlap","pointer","handlerX","getTracker","getLastX","handlerY","getLastY","isPointerInBounds","x","y","otherX","otherY","state","cancelMouseAndPenGestures","currentHandler","getPointerType","MOUSE","PEN","resetTracker","getInstance","instance"],"sources":["C:\\Users\\rm200523\\OneDrive - Université Côte d'Azur\\Documents\\3annee\\triprecapApp\\triprecap\\node_modules\\react-native-gesture-handler\\lib\\module\\web\\tools\\GestureHandlerOrchestrator.ts"],"sourcesContent":["import { State } from '../../State';\nimport { PointerType } from '../interfaces';\n\nimport GestureHandler from '../handlers/GestureHandler';\nimport PointerTracker from './PointerTracker';\n\nexport default class GestureHandlerOrchestrator {\n  private static instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: GestureHandler[] = [];\n  private awaitingHandlers: GestureHandler[] = [];\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: GestureHandler): void {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n\n  public removeHandlerFromOrchestrator(handler: GestureHandler): void {\n    this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n    this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n  }\n\n  private cleanupFinishedHandlers(): void {\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (!handler) {\n        continue;\n      }\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.gestureHandlers.splice(i, 1);\n\n        this.cleanHandler(handler);\n      }\n    }\n  }\n\n  private hasOtherHandlerToWaitFor(handler: GestureHandler): boolean {\n    let hasToWait = false;\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (\n        otherHandler &&\n        !this.isFinished(otherHandler.getState()) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      ) {\n        hasToWait = true;\n        return;\n      }\n    });\n\n    return hasToWait;\n  }\n\n  private tryActivate(handler: GestureHandler): void {\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n    } else if (\n      handler.getState() !== State.CANCELLED &&\n      handler.getState() !== State.FAILED\n    ) {\n      if (this.shouldActivate(handler)) {\n        this.makeActive(handler);\n      } else {\n        switch (handler.getState()) {\n          case State.ACTIVE:\n            handler.fail();\n            break;\n          case State.BEGAN:\n            handler.cancel();\n        }\n      }\n    }\n  }\n\n  private shouldActivate(handler: GestureHandler): boolean {\n    for (const otherHandler of this.gestureHandlers) {\n      if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private cleanupAwaitingHandlers(handler: GestureHandler): void {\n    for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n      if (\n        !this.awaitingHandlers[i].isAwaiting() &&\n        this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)\n      ) {\n        this.cleanHandler(this.awaitingHandlers[i]);\n        this.awaitingHandlers.splice(i, 1);\n      }\n    }\n  }\n\n  public onHandlerStateChange(\n    handler: GestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.isEnabled() && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      this.awaitingHandlers.forEach((otherHandler) => {\n        if (this.shouldHandlerWaitForOther(otherHandler, handler)) {\n          if (newState === State.END) {\n            otherHandler?.cancel();\n            if (otherHandler.getState() === State.END) {\n              // Handle edge case, where discrete gestures end immediately after activation thus\n              // their state is set to END and when the gesture they are waiting for activates they\n              // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n              // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n              otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n            }\n            otherHandler?.setAwaiting(false);\n          } else {\n            this.tryActivate(otherHandler);\n          }\n        }\n      });\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (this.awaitingHandlers.indexOf(handler) < 0) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: GestureHandler): void {\n    const currentState = handler.getState();\n\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      if (this.shouldHandlerBeCancelledBy(this.gestureHandlers[i], handler)) {\n        this.gestureHandlers[i].cancel();\n      }\n    }\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler?.cancel();\n        otherHandler?.setAwaiting(true);\n      }\n    });\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (handler.isAwaiting()) {\n      handler.setAwaiting(false);\n      for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (this.awaitingHandlers[i] === handler) {\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n  }\n\n  private addAwaitingHandler(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n\n  public recordHandlerIfNotPresent(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: GestureHandler,\n    gh2: GestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (\n      handler !== otherHandler &&\n      (handler.isAwaiting() || handler.getState() === State.ACTIVE)\n    ) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.getDelegate().getView() !== otherHandler.getDelegate().getView()\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    let overlap = false;\n\n    handlerPointers.forEach((pointer: number) => {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      if (\n        handler.getDelegate().isPointerInBounds({ x: handlerX, y: handlerY }) &&\n        otherHandler\n          .getDelegate()\n          .isPointerInBounds({ x: handlerX, y: handlerY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    otherPointers.forEach((pointer: number) => {\n      const otherX: number = otherHandler.getTracker().getLastX(pointer);\n      const otherY: number = otherHandler.getTracker().getLastY(pointer);\n\n      if (\n        handler.getDelegate().isPointerInBounds({ x: otherX, y: otherY }) &&\n        otherHandler.getDelegate().isPointerInBounds({ x: otherX, y: otherY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    return overlap;\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: GestureHandler): void {\n    this.gestureHandlers.forEach((handler: GestureHandler) => {\n      if (\n        handler.getPointerType() !== PointerType.MOUSE &&\n        handler.getPointerType() !== PointerType.PEN\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}