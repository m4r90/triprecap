{"ast":null,"code":"import { EventTypes, MouseButtons, PointerType, TouchEventType } from '../interfaces';\nimport EventManager from './EventManager';\nimport { isPointerInBounds } from '../utils';\nexport default class TouchEventManager extends EventManager {\n  setListeners() {\n    this.view.addEventListener('touchstart', event => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent = this.mapEvent(event, EventTypes.DOWN, i, TouchEventType.DOWN);\n        if (!isPointerInBounds(this.view, {\n          x: adaptedEvent.x,\n          y: adaptedEvent.y\n        }) || event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n        this.markAsInBounds(adaptedEvent.pointerId);\n        if (++this.activePointersCounter > 1) {\n          adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_DOWN;\n          this.onPointerAdd(adaptedEvent);\n        } else {\n          this.onPointerDown(adaptedEvent);\n        }\n      }\n    });\n    this.view.addEventListener('touchmove', event => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent = this.mapEvent(event, EventTypes.MOVE, i, TouchEventType.MOVE);\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n        const inBounds = isPointerInBounds(this.view, {\n          x: adaptedEvent.x,\n          y: adaptedEvent.y\n        });\n        const pointerIndex = this.pointersInBounds.indexOf(adaptedEvent.pointerId);\n        if (inBounds) {\n          if (pointerIndex < 0) {\n            adaptedEvent.eventType = EventTypes.ENTER;\n            this.onPointerEnter(adaptedEvent);\n            this.markAsInBounds(adaptedEvent.pointerId);\n          } else {\n            this.onPointerMove(adaptedEvent);\n          }\n        } else {\n          if (pointerIndex >= 0) {\n            adaptedEvent.eventType = EventTypes.LEAVE;\n            this.onPointerLeave(adaptedEvent);\n            this.markAsOutOfBounds(adaptedEvent.pointerId);\n          } else {\n            this.onPointerOutOfBounds(adaptedEvent);\n          }\n        }\n      }\n    });\n    this.view.addEventListener('touchend', event => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        if (this.activePointersCounter === 0) {\n          break;\n        }\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n        const adaptedEvent = this.mapEvent(event, EventTypes.UP, i, TouchEventType.UP);\n        this.markAsOutOfBounds(adaptedEvent.pointerId);\n        if (--this.activePointersCounter > 0) {\n          adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_UP;\n          this.onPointerRemove(adaptedEvent);\n        } else {\n          this.onPointerUp(adaptedEvent);\n        }\n      }\n    });\n    this.view.addEventListener('touchcancel', event => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent = this.mapEvent(event, EventTypes.CANCEL, i, TouchEventType.CANCELLED);\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n        this.onPointerCancel(adaptedEvent);\n        this.markAsOutOfBounds(adaptedEvent.pointerId);\n        this.activePointersCounter = 0;\n      }\n    });\n  }\n  mapEvent(event, eventType, index, touchEventType) {\n    const rect = this.view.getBoundingClientRect();\n    const clientX = event.changedTouches[index].clientX;\n    const clientY = event.changedTouches[index].clientY;\n    return {\n      x: clientX,\n      y: clientY,\n      offsetX: clientX - rect.left,\n      offsetY: clientY - rect.top,\n      pointerId: event.changedTouches[index].identifier,\n      eventType: eventType,\n      pointerType: PointerType.TOUCH,\n      buttons: MouseButtons.NONE,\n      time: event.timeStamp,\n      allTouches: event.touches,\n      changedTouches: event.changedTouches,\n      touchEventType: touchEventType\n    };\n  }\n}","map":{"version":3,"names":["EventTypes","MouseButtons","PointerType","TouchEventType","EventManager","isPointerInBounds","TouchEventManager","setListeners","view","addEventListener","event","i","changedTouches","length","adaptedEvent","mapEvent","DOWN","x","y","touchType","markAsInBounds","pointerId","activePointersCounter","eventType","ADDITIONAL_POINTER_DOWN","onPointerAdd","onPointerDown","MOVE","inBounds","pointerIndex","pointersInBounds","indexOf","ENTER","onPointerEnter","onPointerMove","LEAVE","onPointerLeave","markAsOutOfBounds","onPointerOutOfBounds","UP","ADDITIONAL_POINTER_UP","onPointerRemove","onPointerUp","CANCEL","CANCELLED","onPointerCancel","index","touchEventType","rect","getBoundingClientRect","clientX","clientY","offsetX","left","offsetY","top","identifier","pointerType","TOUCH","buttons","NONE","time","timeStamp","allTouches","touches"],"sources":["C:\\Users\\rm200523\\OneDrive - Université Côte d'Azur\\Documents\\3annee\\triprecapApp\\triprecap\\node_modules\\react-native-gesture-handler\\lib\\module\\web\\tools\\TouchEventManager.ts"],"sourcesContent":["import {\n  AdaptedEvent,\n  EventTypes,\n  MouseButtons,\n  PointerType,\n  TouchEventType,\n} from '../interfaces';\nimport EventManager from './EventManager';\nimport { isPointerInBounds } from '../utils';\n\nexport default class TouchEventManager extends EventManager<HTMLElement> {\n  public setListeners(): void {\n    this.view.addEventListener('touchstart', (event: TouchEvent) => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent: AdaptedEvent = this.mapEvent(\n          event,\n          EventTypes.DOWN,\n          i,\n          TouchEventType.DOWN\n        );\n\n        // Here we skip stylus, because in case of anything different than touch we want to handle it by using PointerEvents\n        // If we leave stylus to send touch events, handlers will receive every action twice\n        if (\n          !isPointerInBounds(this.view, {\n            x: adaptedEvent.x,\n            y: adaptedEvent.y,\n          }) ||\n          //@ts-ignore touchType field does exist\n          event.changedTouches[i].touchType === 'stylus'\n        ) {\n          continue;\n        }\n\n        this.markAsInBounds(adaptedEvent.pointerId);\n\n        if (++this.activePointersCounter > 1) {\n          adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_DOWN;\n          this.onPointerAdd(adaptedEvent);\n        } else {\n          this.onPointerDown(adaptedEvent);\n        }\n      }\n    });\n\n    this.view.addEventListener('touchmove', (event: TouchEvent) => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent: AdaptedEvent = this.mapEvent(\n          event,\n          EventTypes.MOVE,\n          i,\n          TouchEventType.MOVE\n        );\n        //@ts-ignore touchType field does exist\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n\n        const inBounds: boolean = isPointerInBounds(this.view, {\n          x: adaptedEvent.x,\n          y: adaptedEvent.y,\n        });\n\n        const pointerIndex: number = this.pointersInBounds.indexOf(\n          adaptedEvent.pointerId\n        );\n\n        if (inBounds) {\n          if (pointerIndex < 0) {\n            adaptedEvent.eventType = EventTypes.ENTER;\n            this.onPointerEnter(adaptedEvent);\n            this.markAsInBounds(adaptedEvent.pointerId);\n          } else {\n            this.onPointerMove(adaptedEvent);\n          }\n        } else {\n          if (pointerIndex >= 0) {\n            adaptedEvent.eventType = EventTypes.LEAVE;\n            this.onPointerLeave(adaptedEvent);\n            this.markAsOutOfBounds(adaptedEvent.pointerId);\n          } else {\n            this.onPointerOutOfBounds(adaptedEvent);\n          }\n        }\n      }\n    });\n\n    this.view.addEventListener('touchend', (event: TouchEvent) => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        // When we call reset on gesture handlers, it also resets their event managers\n        // In some handlers (like RotationGestureHandler) reset is called before all pointers leave view\n        // This means, that activePointersCounter will be set to 0, while there are still remaining pointers on view\n        // Removing them will end in activePointersCounter going below 0, therefore handlers won't behave properly\n        if (this.activePointersCounter === 0) {\n          break;\n        }\n\n        //@ts-ignore touchType field does exist\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n\n        const adaptedEvent: AdaptedEvent = this.mapEvent(\n          event,\n          EventTypes.UP,\n          i,\n          TouchEventType.UP\n        );\n\n        this.markAsOutOfBounds(adaptedEvent.pointerId);\n\n        if (--this.activePointersCounter > 0) {\n          adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_UP;\n          this.onPointerRemove(adaptedEvent);\n        } else {\n          this.onPointerUp(adaptedEvent);\n        }\n      }\n    });\n\n    this.view.addEventListener('touchcancel', (event: TouchEvent) => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent: AdaptedEvent = this.mapEvent(\n          event,\n          EventTypes.CANCEL,\n          i,\n          TouchEventType.CANCELLED\n        );\n\n        //@ts-ignore touchType field does exist\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n\n        this.onPointerCancel(adaptedEvent);\n        this.markAsOutOfBounds(adaptedEvent.pointerId);\n        this.activePointersCounter = 0;\n      }\n    });\n  }\n\n  protected mapEvent(\n    event: TouchEvent,\n    eventType: EventTypes,\n    index: number,\n    touchEventType: TouchEventType\n  ): AdaptedEvent {\n    const rect = this.view.getBoundingClientRect();\n    const clientX = event.changedTouches[index].clientX;\n    const clientY = event.changedTouches[index].clientY;\n\n    return {\n      x: clientX,\n      y: clientY,\n      offsetX: clientX - rect.left,\n      offsetY: clientY - rect.top,\n      pointerId: event.changedTouches[index].identifier,\n      eventType: eventType,\n      pointerType: PointerType.TOUCH,\n      buttons: MouseButtons.NONE,\n      time: event.timeStamp,\n      allTouches: event.touches,\n      changedTouches: event.changedTouches,\n      touchEventType: touchEventType,\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}